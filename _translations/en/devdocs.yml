examples:
  intro:
    content: >
      The following guide aims to provide examples to help you start
      building Bitcoin-based applications. To make the best use of this document,
      you may want to install the current version of Bitcoin Core, either from
      [source][core git] or from a [pre-compiled executable][core executable].

      Once installed, you'll have access to three programs: `bitcoind`,
      `bitcoin-qt`, and `bitcoin-cli`.

      * `bitcoin-qt` provides a combination full Bitcoin peer and wallet
        frontend. From the Help menu, you can access a console where you can
        enter the RPC commands used throughout this document.

      * `bitcoind` is more useful for programming: it provides a full peer
        which you can interact with through RPCs to port 8332 (or 18332
        for testnet).

      * `bitcoin-cli` allows you to send RPC commands to `bitcoind` from the
        command line.  For example, `bitcoin-cli help`

      All three programs get settings from `bitcoin.conf` in the `Bitcoin`
      application directory:

      * Windows: `%APPDATA%\Bitcoin\`

      * OSX: `$HOME/Library/Application Support/Bitcoin/`

      * Linux: `$HOME/.bitcoin/`

      To use `bitcoind` and `bitcoin-cli`, you will need to add a RPC password
      to your `bitcoin.conf` file. Both programs will read from the same file
      if both run on the same system as the same user, so any long random
      password will work:

      ~~~
      rpcpassword=change_this_to_a_long_random_password
      ~~~~

      You should also make the `bitcoin.conf` file only readable to its
      owner.  On Linux, Mac OSX, and other Unix-like systems, this can be
      accomplished by running the following command in the Bitcoin application
      directory:

      ~~~
      chmod 0600 bitcoin.conf
      ~~~

      For development, it's safer and cheaper to use Bitcoin's test network (testnet)
      or regression test mode (regtest) described below.

      Questions about Bitcoin use are best sent to the [BitcoinTalk forum][forum
      tech support] and [IRC channels][]. Errors or suggestions related to
      documentation on Bitcoin.org can be [submitted as an issue][docs issue]
      or posted to the [bitcoin-documentation mailing list][].

      In the following documentation, some strings have been shortened or wrapped: "[...]"
      indicates extra data was removed, and lines ending in a single backslash "\\"
      are continued below. If you hover your mouse over a paragraph, cross-reference
      links will be shown in blue.  If you hover over a cross-reference link, a brief
      definition of the term will be displayed in a tooltip.
  transactions:
    header: Transactions
    tutorial:
      header: Transactions Tutorial
      content: >
        Creating transactions is something most Bitcoin applications do.
        This section describes how to use Bitcoin Core's RPC interface to
        create transactions with various attributes.

        Your applications may use something besides Bitcoin Core to create
        transactions, but in any system, you will need to provide the same kinds
        of data to create transactions with the same attributes as those
        described below.

        In order to use this tutorial, you will need to setup [Bitcoin Core][core executable]
        and create a regression test mode environment with 50 BTC in your test
        wallet.

    simple_spending:
      header: Simple Spending
      content:
        part_1: >
          Bitcoin Core provides several RPCs which handle all the details of
          spending, including creating change outputs and paying appropriate fees.
          Even advanced users should use these RPCs whenever possible to decrease
          the chance that satoshis will be lost by mistake.

        part_2: >
          Get a new Bitcoin address and save it in the shell variable `$NEW_ADDRESS`.

        part_3: >
          Send 10 bitcoins to the address using the `sendtoaddress` RPC.  The
          returned hex string is the transaction identifier (txid).

          The `sendtoaddress` RPC automatically selects an unspent transaction
          output (UTXO) from which to spend the satoshis. In this case, it
          withdrew the satoshis from our only available UTXO, the coinbase
          transaction for block #1 which matured with the creation of block #101.
          To spend a specific UTXO, you could use the `sendfrom` RPC instead.

        part_4: >
          Use the `listunspent` RPC to display the UTXOs belonging to this wallet.
          The list is empty because it defaults to only showing confirmed
          UTXOs and we just spent our only confirmed UTXO.

        part_5: >
          Re-running the `listunspent` RPC with the argument "0" to also display
          unconfirmed transactions shows that we have two UTXOs, both with the
          same txid. The first UTXO shown is a change output that `sendtoaddress`
          created using a new address from the key pool. The second UTXO shown is
          the spend to the address we provided. If we had spent those satoshis to
          someone else, that second transaction would not be displayed in our
          list of UTXOs.

        part_6: >
          Create a new block to confirm the transaction above (takes less than a
          second) and clear the shell variable.

    simple_raw_transaction:
      header: Simple Raw Transaction
      content:
        part_1: >
          The raw transaction RPCs allow users to create custom transactions and
          delay broadcasting those transactions. However, mistakes made in raw
          transactions may not be detected by Bitcoin Core, and a number of raw
          transaction users have permanently lost large numbers of satoshis, so
          please be careful using raw transactions on mainnet.

          This subsection covers one of the simplest possible raw transactions.

        part_2: >
          Re-rerun `listunspent`. We now have three UTXOs: the two transactions we
          created before plus the coinbase transaction from block #2. We save the
          txid and output index number (vout) of that coinbase UTXO to shell
          variables.

        part_3: >
          Get a new address to use in the raw transaction.

        part_4: >
          Using two arguments to the `createrawtransaction` RPC, we create a new
          raw format transaction. The first argument (a JSON array) references
          the txid of the coinbase transaction from block #2 and the index
          number (0) of the output from that transaction we want to spend. The
          second argument (a JSON object) creates the output with the address
          (public key hash) and number of bitcoins we want to transfer.
          We save the resulting raw format transaction to a shell variable.

        part_5: >
           **Warning:** `createrawtransaction` does not automatically create change
          outputs, so you can easily accidentally pay a large transaction fee. In
          this example, our input had 50.0000 bitcoins and our output
          (`$NEW_ADDRESS`) is being paid 49.9999 bitcoins, so the transaction will
          include a fee of 0.0001 bitcoins. If we had paid `$NEW_ADDRESS` only 10
          bitcoins with no other changes to this transaction, the transaction fee
          would be a whopping 40 bitcoins. See the Complex Raw Transaction
          subsection below for how to create a transaction with multiple outputs so you
          can send the change back to yourself.

        part_6: >
          Use the `decoderawtransaction` RPC to see exactly what the transaction
          we just created does.

        part_7: >
          Use the `signrawtransaction` RPC to sign the transaction created by
          `createrawtransaction` and save the returned "hex" raw format signed
          transaction to a shell variable. 

          Even though the transaction is now complete, the Bitcoin Core node we're
          connected to doesn't know anything about the transaction, nor does any
          other part of the network. We've created a spend, but we haven't
          actually spent anything because we could simply unset the
          `$SIGNED_RAW_TX` variable to eliminate the transaction.

        part_8: >
          Send the signed transaction to the connected node using the
          `sendrawtransaction` RPC. After accepting the transaction, the node
          would usually then broadcast it to other peers, but we're not currently
          connected to other peers because we started in regtest mode.

        part_9: >
          Generate a block to confirm the transaction and clear our shell
          variables.

    complex_raw_transaction:
      header: Complex Raw Transaction
      content: >
        part_1: >
          In this example, we'll create a transaction with two inputs and two
          outputs.  We'll sign each of the inputs separately, as might happen if
          the two inputs belonged to different people who agreed to create a
          transaction together (such as a CoinJoin transaction).

        part_2: >
          For our two inputs, we select two UTXOs by placing the txid and output
          index numbers (vouts) in shell variables.  We also save the addresses
          corresponding to the public keys (hashed or unhashed) used in those
          transactions. We need the addresses so we can get the corresponding
          private keys from our wallet.

        part_3: >
          Use the `dumpprivkey` RPC to get the private keys corresponding to the
          public keys used in the two UTXOs out inputs we will be spending.  We need
          the private keys so we can sign each of the inputs separately.

        part_4: >
          ![Warning icon](/img/icons/icon_warning.svg)
          **Warning:** Users should never manually manage private keys on mainnet.
          As dangerous as raw transactions are (see warnings above), making a
          mistake with a private key can be much worse---as in the case of a HD
          wallet [cross-generational key compromise][devguide hardened keys].
          These examples are to help you learn, not for you to emulate on
          mainnet.

        part_5: >
          For our two outputs, get two new addresses.

        part_6: >
          Create the raw transaction using `createrawtransaction` much the same as
          before, except now we have two inputs and two outputs.

        part_7: >
          Signing the raw transaction with `signrawtransaction` gets more
          complicated as we now have three arguments:

          1. The unsigned raw transaction.

          2. An empty array. We don't do anything with this argument in this
          operation, but some valid JSON must be provided to get access to the
          later positional arguments.

          3. The private key we want to use to sign one of the inputs.

          The result is a raw transaction with only one input signed; the fact
          that the transaction isn't fully signed is indicated by value of the
          `complete` JSON field.  We save the incomplete, partly-signed raw
          transaction hex to a shell variable.

        part_8: >
          To sign the second input, we repeat the process we used to sign the
          first input using the second private key. Now that both inputs are
          signed, the `complete` result is *true*.

        part_9:
          Clean up the shell variables used. Unlike previous subsections, we're
          not going to send this transaction to the connected node with
          `sendrawtransaction`. This will allow us to illustrate in the Offline
          Signing subsection below how to spend a transaction which is not yet in
          the block chain or memory pool.

    offline_signing:
      header: Offline Signing
      content:
        part_1: >
          We will now spend the transaction created in the Complex Raw Transaction
          subsection above without sending it to the local node first. This is the
          same basic process used by wallet programs for offline
          signing---which generally means signing a transaction without access
          to the current UTXO set.

          Offline signing is safe. However, in this example we will also be
          spending an output which is not part of the block chain because the
          transaction containing it has never been broadcast. That can be unsafe:

        part_2:
          **Warning:** Transactions which spend outputs from unconfirmed
          transactions are vulnerable to transaction malleability. Be sure to read
          about transaction malleability and adopt good practices before spending
          unconfirmed transactions on mainnet.

        part_3: >
          Put the previously signed (but not sent) transaction into a shell
          variable.

        part_4: >
          Decode the signed raw transaction so we can get its txid. Also, choose a
          specific one of its UTXOs to spend and save that UTXO's output index number
          (vout) and hex pubkey script (scriptPubKey) into shell variables.

        part_5: >
          Get a new address to spend the satoshis to.

        part_6: >
          Create the raw transaction the same way we've done in the previous
          subsections.

        part_7: >
          Attempt to sign the raw transaction without any special arguments, the
          way we successfully signed the the raw transaction in the Simple Raw
          Transaction subsection. If you've read the [Transaction section][transaction] of
          the guide, you may know why the call fails and leaves the raw
          transaction hex unchanged.

          ![Old Transaction Data Required To Be Signed](/img/dev/en-signing-output-to-spend.svg)

          As illustrated above, the data that gets signed includes the txid and
          vout from the previous transaction.  That information is included in the
          `createrawtransaction` raw transaction.  But the data that gets signed
          also includes the pubkey script from the previous transaction, even
          though it doesn't appear in either the unsigned or signed transaction.

          In the other raw transaction subsections above, the previous output was
          part of the UTXO set known to the wallet, so the wallet was able to use
          the txid and output index number to find the previous pubkey script and
          insert it automatically.

          In this case, you're spending an output which is unknown to the wallet,
          so it can't automatically insert the previous pubkey script.

        part_8: >
          Successfully sign the transaction by providing the previous pubkey
          script and other required input data. 

          This specific operation is typically what offline signing wallets do.
          The online wallet creates the raw transaction and gets the previous
          pubkey scripts for all the inputs. The user brings this information to
          the offline wallet. After displaying the transaction details to the
          user, the offline wallet signs the transaction as we did above. The
          user takes the signed transaction back to the online wallet, which
          broadcasts it.

        part_9: >
          Attempt to broadcast the second transaction before we've broadcast the
          first transaction.  The node rejects this attempt because the second
          transaction spends an output which is not a UTXO the node knows about.
        part_10: >
          Broadcast the first transaction, which succeeds, and then broadcast the
          second transaction---which also now succeeds because the node now sees
          the UTXO.

        part_11: >
          We have once again not generated an additional block, so the transactions
          above have not yet become part of the regtest block chain.  However, they
          are part of the local node's memory pool.

    p2sh_multisig:
      header: P2SH Multisig
      content:
        part_1: >
          In this subsection, we will create a P2SH multisig address, spend
          satoshis to it, and then spend those satoshis from it to another
          address.

          Creating a multisig address is easy. Multisig outputs have two
          parameters, the *minimum* number of signatures required (*m*) and the
          *number* of public keys to use to validate those signatures. This is
          called m-of-n, and in this case we'll be using 2-of-3.

        part_2: >
          Generate three new P2PKH addresses. P2PKH addresses cannot be used with
          the multisig redeem script created below. (Hashing each public key is
          unnecessary anyway---all the public keys are protected by a hash when
          the redeem script is hashed.) However, Bitcoin Core uses addresses as a
          way to reference the underlying full (unhashed) public keys it knows
          about, so we get the three new addresses above in order to use their
          public keys.

          Recall from the Guide that the hashed public keys used in addresses
          obfuscate the full public key, so you cannot give an address to another
          person or device as part of creating a typical multisig output or P2SH multisig
          redeem script. You must give them a full public key.

        part_3: >
          Use the `validateaddress` RPC to display the full (unhashed) public key
          for one of the addresses.  This is the information which will 
          actually be included in the multisig redeem script.  This is also the
          information you would give another person or device as part of creating
          a multisig output or P2SH multisig redeem script.

          We save the address returned to a shell variable.

        part_4: >
          Use the `createmultisig` RPC with two arguments, the number (*n*) of
          signatures required and a list of addresses or public keys.  Because
          P2PKH addresses can't be used in the multisig redeem script created by this
          RPC, the only addresses which can be provided are those belonging to a
          public key in the wallet.  In this case, we provide two addresses and
          one public key---all of which will be converted to public keys in the
          redeem script.

          The P2SH address is returned along with the redeem script which must be
          provided when we spend satoshis sent to the P2SH address.

          ![Warning icon](/img/icons/icon_warning.svg)
          **Warning:** You must not lose the redeem script, especially if you
          don't have a record of which public keys you used to create the P2SH
          multisig address. You need the redeem script to spend any bitcoins sent
          to the P2SH address. If you lose the redeem script, you can recreate it
          by running the same command above, with the public keys listed in the
          same order. However, if you lose both the redeem script and even one of
          the public keys, you will never be able to spend satoshis sent to that
          P2SH address.

          Neither the address nor the redeem script are stored in the wallet when
          you use `createmultisig`. To store them in the wallet, use the
          `addmultisigaddress` RPC instead.  If you add an address to the wallet,
          you should also make a new backup.

        part_5: >
          Paying the P2SH multisig address with Bitcoin Core is as simple as
          paying a more common P2PKH address. Here we use the same command (but
          different variable) we used in the Simple Spending subsection. As
          before, this command automatically selects an UTXO, creates a change
          output to a new one of our P2PKH addresses if necessary, and pays a
          transaction fee if necessary.

          We save that txid to a shell variable as the txid of the UTXO we plan to spend next.

        part_6: >
          We use the `getrawtransaction` RPC with the optional second argument
          (*true*) to get the decoded transaction we just created with
          `spendtoaddress`. We choose one of the outputs to be our UTXO and get
          its output index number (vout) and pubkey script (scriptPubKey).

        part_7: >
          We generate a new P2PKH address to use in the output we're about to
          create.

        part_8: >
          We generate the raw transaction the same way we did in the Simple Raw
          Transaction subsection.

        part_9: >
          We get the private keys for two of the public keys we used to create the
          transaction, the same way we got private keys in the Complex Raw
          Transaction subsection. Recall that we created a 2-of-3 multisig pubkey script,
          so signatures from two private keys are needed.

          ![Warning icon](/img/icons/icon_warning.svg)
          **Reminder:** Users should never manually manage private keys on
          mainnet. See the warning in the [complex raw transaction section][devex
          complex raw transaction].

        part_10: >
          We make the first signature. The input argument (JSON object) takes the
          additional redeem script parameter so that it can append the redeem script
          to the signature script after the two signatures.

        part_11: >
          The `signrawtransaction` call used here is nearly identical to the one
          used above.  The only difference is the private key used.  Now that the
          two required signatures have been provided, the transaction is marked as
          complete.

        part_12: >
          We send the transaction spending the P2SH multisig output to the local
          node, which accepts it.
